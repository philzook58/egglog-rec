REC-SPEC Sieve
# common definitions to be included in the REC/sieve*.rec benchmarks

SORTS
  Bool List Nat Digit
CONS
  true : -> Bool
  false : -> Bool
  s : Nat -> Nat
  z : -> Nat
  d0 : -> Digit
  d1 : -> Digit
  d2 : -> Digit
  d3 : -> Digit
  d4 : -> Digit
  d5 : -> Digit
  d6 : -> Digit
  d7 : -> Digit
  d8 : -> Digit
  d9 : -> Digit
  nil : -> List
  d : Digit -> List		# originally: list : Digit -> List
  dl : Digit List -> List
  l : Nat List -> List          # {strat (0)}
  ll : List List -> List
OPNS
  lt : Nat Nat -> Bool
  sub : Nat Nat -> Nat
  div : Nat Nat -> Nat
  rem : Nat Nat -> Nat
  add : Nat Nat -> Nat
  divides : Nat Nat -> Bool
  mult : Nat Nat -> Nat
  two : -> Nat
  ten : -> Nat
  find : List Nat -> Digit
  digitList : -> List
  ap : List List -> List
  conv : Nat -> List
  digit : Nat -> Digit
  fact : Nat -> Nat
  auxdiv : Nat Nat Nat -> Bool
  ifNat : Bool Nat Nat -> Nat      # {strat(1 0 2 3)}

  # The Primes Sieve #

  # force : List Nat -> List      # specific to lazy evaluation
  # intsFrom : Nat -> List
  intsBetween : Nat Nat -> List   # CONVECS: replacement for force()
  sieve : List -> List
  filter : List Nat -> List
  e : Nat List -> List          # {strat (1 2 0)}
VARS
  N M X Y A B : Nat
  L1 L2 : List
  Dig : Digit			# originally : D:Digit
RULES
  # constants first
  two -> s(s(z))

  ten -> s(s(s(s(s(s(s(s(s(s(z))))))))))

  digitList -> dl(d0, dl(d1, dl(d2, dl(d3, dl(d4, dl(d5, dl(d6, dl(d7, dl(d8, dl(d9, nil))))))))))

  # functions

  ifNat(true, N, M) -> N
  ifNat(false, N, M) -> M

  conv(X) -> dl(digit(X), nil) if lt(X, ten) = true
  conv(X) -> ap(conv(div(X, ten)), conv(rem(X, ten))) if lt(X, ten) = false

  rem(X, Y) -> ifNat(lt(X, Y), X, rem(sub(X, Y), Y)) if Y <> z
  # Hubert: added missing guard to prevent infinite rewrite if Y = z

  div(X, Y) -> ifNat(lt(X, Y), z, s(div(sub(X, Y), Y))) if Y <> z
 # Hubert: added missing guard to prevent infinite rewrite if Y = z

  lt(z, s(X)) -> true
  lt(X, z) -> false
  lt(s(X), s(Y)) -> lt(X, Y)

  # sub(z, X) -> z   #---- this created ambiguity for sub(z,z)
  sub(z, s(Y)) -> z
  sub(X, z) -> X
  sub(s(X), s(Y)) -> sub(X, Y)

  digit(X) -> find(digitList, X)

  find(dl(Dig, L1), z) -> Dig
  find(dl(Dig, L1), s(X)) -> find(L1, X)

  ap(nil, L1) -> L1
  ap(dl(Dig, L1), L2) -> dl(Dig, ap(L1, L2))

  add(z, Y) -> Y
  add(s(X), Y) -> s(add(X, Y))

  mult(z, Y) -> z
  mult(s(X), Y) -> add(Y, mult(X, Y))

  fact(z) -> s(z)
  fact(s(X)) -> mult(s(X), fact(X))

  divides(N, M) -> auxdiv(N, M, M) if M <> z

  auxdiv(z, z, M) -> true
  auxdiv(z, s(X), M) -> false
  auxdiv(s(X), s(Y), M) -> auxdiv(X, Y, M)
  auxdiv(s(X), z, M) -> auxdiv(s(X), M, M)

  # The Primes Sieve #

  # intsFrom(N) -> l(N, intsFrom(s(N)))        # infinite list of Nats

  # added by CONVECS
  # assert that always N <= M in intsBetween (N, M)
  intsBetween (N, M) -> nil  if N = M
  intsBetween (N, M) -> l (N, intsBetween (s(N), M)) if N <> M

  sieve(l(N, L1)) -> l(N, sieve(filter(L1, N)))  # the actual sieve
  sieve(nil) -> nil

  filter(l(N, L1), M) -> filter(L1, M) if divides(N, M) = true
  filter(l(N, L1), M) -> l(N, filter(L1, M)) if divides(N, M) = false
  filter(nil, M) -> nil

  # commented out by CONVECS
  # force(L1, z) -> nil
  # force(l(N, L1), s(M)) -> e(N, force(L1, M))    # force lazy list

  e(N, L1) -> ll(conv(N), L1)                    # convert to decimal

EVAL
END-SPEC
