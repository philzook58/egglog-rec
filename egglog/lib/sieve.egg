
(datatype Bool)
(datatype List)
(datatype Nat)
(datatype Digit)
(function mytrue () Bool)
(function myfalse () Bool)
(function s (Nat) Nat)
(function z () Nat)
(function d0 () Digit)
(function d1 () Digit)
(function d2 () Digit)
(function d3 () Digit)
(function d4 () Digit)
(function d5 () Digit)
(function d6 () Digit)
(function d7 () Digit)
(function d8 () Digit)
(function d9 () Digit)
(function nil () List)
(function d (Digit) List)
(function dl (Digit List) List)
(function l (Nat List) List)
(function ll (List List) List)
(function lt (Nat Nat) Bool)
(function sub (Nat Nat) Nat)
(function div (Nat Nat) Nat)
(function rem (Nat Nat) Nat)
(function add (Nat Nat) Nat)
(function divides (Nat Nat) Bool)
(function mult (Nat Nat) Nat)
(function two () Nat)
(function ten () Nat)
(function find (List Nat) Digit)
(function digitList () List)
(function ap (List List) List)
(function conv (Nat) List)
(function digit (Nat) Digit)
(function fact (Nat) Nat)
(function auxdiv (Nat Nat Nat) Bool)
(function ifNat (Bool Nat Nat) Nat)
(function intsBetween (Nat Nat) List)
(function sieve (List) List)
(function filter (List Nat) List)
(function e (Nat List) List)
(rewrite two (s (s z)) )
(rewrite ten (s (s (s (s (s (s (s (s (s (s z)))))))))) )
(rewrite digitList (dl d0 (dl d1 (dl d2 (dl d3 (dl d4 (dl d5 (dl d6 (dl d7 (dl d8 (dl d9 nil)))))))))) )
(rewrite (ifNat mytrue N M) N )
(rewrite (ifNat myfalse N M) M )
(rewrite (conv X) (dl (digit X) nil) :when ((= (lt X ten) mytrue)))
(rewrite (conv X) (ap (conv (div X ten)) (conv (rem X ten))) :when ((= (lt X ten) myfalse)))
(rewrite (rem X Y) (ifNat (lt X Y) X (rem (sub X Y) Y)) :when ((!= Y z)))
(rewrite (div X Y) (ifNat (lt X Y) z (s (div (sub X Y) Y))) :when ((!= Y z)))
(rewrite (lt z (s X)) mytrue )
(rewrite (lt X z) myfalse )
(rewrite (lt (s X) (s Y)) (lt X Y) )
(rewrite (sub z (s Y)) z )
(rewrite (sub X z) X )
(rewrite (sub (s X) (s Y)) (sub X Y) )
(rewrite (digit X) (find digitList X) )
(rewrite (find (dl Dig L1) z) Dig )
(rewrite (find (dl Dig L1) (s X)) (find L1 X) )
(rewrite (ap nil L1) L1 )
(rewrite (ap (dl Dig L1) L2) (dl Dig (ap L1 L2)) )
(rewrite (add z Y) Y )
(rewrite (add (s X) Y) (s (add X Y)) )
(rewrite (mult z Y) z )
(rewrite (mult (s X) Y) (add Y (mult X Y)) )
(rewrite (fact z) (s z) )
(rewrite (fact (s X)) (mult (s X) (fact X)) )
(rewrite (divides N M) (auxdiv N M M) :when ((!= M z)))
(rewrite (auxdiv z z M) mytrue )
(rewrite (auxdiv z (s X) M) myfalse )
(rewrite (auxdiv (s X) (s Y) M) (auxdiv X Y M) )
(rewrite (auxdiv (s X) z M) (auxdiv (s X) M M) )
(rewrite (intsBetween N M) nil :when ((= N M)))
(rewrite (intsBetween N M) (l N (intsBetween (s N) M)) :when ((!= N M)))
(rewrite (sieve (l N L1)) (l N (sieve (filter L1 N))) )
(rewrite (sieve nil) nil )
(rewrite (filter (l N L1) M) (filter L1 M) :when ((= (divides N M) mytrue)))
(rewrite (filter (l N L1) M) (l N (filter L1 M)) :when ((= (divides N M) myfalse)))
(rewrite (filter nil M) nil )
(rewrite (e N L1) (ll (conv N) L1) )